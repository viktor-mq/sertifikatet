# app/learning/models.py
from datetime import datetime
from app import db
from sqlalchemy.dialects.mysql import JSON


class LearningModule(db.Model):
    """Learning modules for structured driving theory curriculum"""
    __tablename__ = 'learning_modules'
    
    id = db.Column(db.Integer, primary_key=True)
    module_number = db.Column(db.Integer, nullable=False, unique=True)  # 1, 2, 3, 4, 5
    title = db.Column(db.String(200), nullable=False)
    description = db.Column(db.Text)
    estimated_hours = db.Column(db.Float)  # Estimated completion time
    prerequisites = db.Column(JSON)  # Required prior modules/skills
    learning_objectives = db.Column(JSON)  # What users will learn
    content_directory = db.Column(db.String(255))  # File system path
    is_active = db.Column(db.Boolean, default=True)
    ai_generated = db.Column(db.Boolean, default=False)
    last_content_update = db.Column(db.DateTime)  # When content was last modified
    completion_rate = db.Column(db.Float, default=0.0)  # Overall completion percentage
    average_time_spent = db.Column(db.Integer, default=0)  # Average minutes users spend
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    submodules = db.relationship('LearningSubmodule', backref='module', lazy='dynamic', cascade='all, delete-orphan')
    user_progress = db.relationship('UserLearningProgress', backref='learning_module', lazy='dynamic')
    
    def __repr__(self):
        return f'<LearningModule {self.module_number}: {self.title}>'
    
    def get_completion_rate_for_user(self, user_id):
        """Calculate completion rate for specific user"""
        total_submodules = self.submodules.filter_by(is_active=True).count()
        if total_submodules == 0:
            return 0.0
        
        completed_submodules = UserLearningProgress.query.filter_by(
            user_id=user_id,
            module_id=self.id,
            status='completed'
        ).filter(UserLearningProgress.submodule_id.isnot(None)).count()
        
        return (completed_submodules / total_submodules) * 100


class LearningSubmodule(db.Model):
    """Submodules within learning modules (e.g., 1.1, 1.2, etc.)"""
    __tablename__ = 'learning_submodules'
    
    id = db.Column(db.Integer, primary_key=True)
    module_id = db.Column(db.Integer, db.ForeignKey('learning_modules.id'), nullable=False)
    submodule_number = db.Column(db.Float, nullable=False)  # 1.1, 1.2, 2.1, etc.
    title = db.Column(db.String(200), nullable=False)
    description = db.Column(db.Text)
    content_file_path = db.Column(db.String(500))  # Path to content.md
    summary_file_path = db.Column(db.String(500))  # Path to summary.md
    shorts_directory = db.Column(db.String(500))  # Path to shorts/ folder
    estimated_minutes = db.Column(db.Integer)  # Time to complete
    difficulty_level = db.Column(db.Integer, default=1)  # 1-5 difficulty rating
    has_quiz = db.Column(db.Boolean, default=False)  # Has associated quiz questions
    quiz_question_count = db.Column(db.Integer, default=0)  # Number of quiz questions
    has_video_shorts = db.Column(db.Boolean, default=False)  # Has TikTok-style videos
    shorts_count = db.Column(db.Integer, default=0)  # Number of short videos
    is_active = db.Column(db.Boolean, default=True)
    ai_generated_content = db.Column(db.Boolean, default=False)  # Content generated by AI
    ai_generated_summary = db.Column(db.Boolean, default=False)  # Summary generated by AI
    content_version = db.Column(db.String(50), default='1.0')  # Content version tracking
    last_content_update = db.Column(db.DateTime)  # When files were last modified
    engagement_score = db.Column(db.Float, default=0.0)  # User engagement metrics
    completion_rate = db.Column(db.Float, default=0.0)  # Completion percentage
    average_study_time = db.Column(db.Integer, default=0)  # Average minutes spent
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    video_shorts = db.relationship('VideoShorts', backref='submodule', lazy='dynamic', cascade='all, delete-orphan')
    user_progress = db.relationship('UserLearningProgress', backref='learning_submodule', lazy='dynamic')
    
    # Unique constraint on module_id + submodule_number
    __table_args__ = (db.UniqueConstraint('module_id', 'submodule_number', name='_module_submodule_uc'),)
    
    def __repr__(self):
        return f'<LearningSubmodule {self.submodule_number}: {self.title}>'
    
    def get_content_path(self):
        """Get full path to content.md file"""
        if self.content_file_path:
            return self.content_file_path
        return f"content/modules/{self.module.module_number}-{self.module.content_directory}/{self.submodule_number}-{self.title.lower().replace(' ', '-')}/content.md"
    
    def get_summary_path(self):
        """Get full path to summary.md file"""
        if self.summary_file_path:
            return self.summary_file_path
        return f"content/modules/{self.module.module_number}-{self.module.content_directory}/{self.submodule_number}-{self.title.lower().replace(' ', '-')}/summary.md"


class VideoShorts(db.Model):
    """Short-form educational videos in TikTok style (9:16 format)"""
    __tablename__ = 'video_shorts'
    
    id = db.Column(db.Integer, primary_key=True)
    submodule_id = db.Column(db.Integer, db.ForeignKey('learning_submodules.id'), nullable=False)
    title = db.Column(db.String(200), nullable=False)
    description = db.Column(db.Text)
    filename = db.Column(db.String(255), nullable=False)  # Video filename
    file_path = db.Column(db.String(500), nullable=False)  # Full file path
    duration_seconds = db.Column(db.Integer)  # Video duration
    sequence_order = db.Column(db.Integer, default=0)  # Order within submodule
    aspect_ratio = db.Column(db.String(10), default='9:16')  # '9:16' for TikTok-style
    resolution = db.Column(db.String(20))  # '1080x1920' etc.
    file_size_mb = db.Column(db.Float)  # File size for bandwidth optimization
    thumbnail_path = db.Column(db.String(500))  # Thumbnail image path
    has_captions = db.Column(db.Boolean, default=False)  # Has subtitle/caption file
    caption_file_path = db.Column(db.String(500))  # Path to captions
    topic_tags = db.Column(JSON)  # Array of topic tags
    difficulty_level = db.Column(db.Integer, default=1)  # 1-5 difficulty rating
    engagement_score = db.Column(db.Float, default=0.0)  # Average user engagement
    view_count = db.Column(db.Integer, default=0)  # Total views
    completion_rate = db.Column(db.Float, default=0.0)  # Percentage who watch to end
    average_watch_time = db.Column(db.Float, default=0.0)  # Average seconds watched
    like_count = db.Column(db.Integer, default=0)  # User likes (if implemented)
    ai_generated = db.Column(db.Boolean, default=False)  # Generated by AI
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    user_progress = db.relationship('UserShortsProgress', backref='video_short', lazy='dynamic')
    
    def __repr__(self):
        return f'<VideoShorts {self.sequence_order}: {self.title}>'
    
    def get_full_path(self):
        """Get full path to video file"""
        return self.file_path
    
    def update_engagement_metrics(self):
        """Update engagement metrics based on user interactions"""
        total_views = self.user_progress.count()
        if total_views == 0:
            return
        
        completed_views = self.user_progress.filter_by(watch_status='completed').count()
        self.completion_rate = (completed_views / total_views) * 100
        
        # Calculate average watch time
        progress_records = self.user_progress.filter(
            UserShortsProgress.watch_time_seconds > 0
        ).all()
        
        if progress_records:
            total_watch_time = sum(p.watch_time_seconds for p in progress_records)
            self.average_watch_time = total_watch_time / len(progress_records)
        
        # Update view count
        self.view_count = total_views
        
        # Calculate engagement score (combination of completion rate and likes)
        like_rate = (self.like_count / total_views) if total_views > 0 else 0
        self.engagement_score = (self.completion_rate * 0.7) + (like_rate * 100 * 0.3)


class UserLearningProgress(db.Model):
    """Track user progress through learning modules and submodules"""
    __tablename__ = 'user_learning_progress'
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    module_id = db.Column(db.Integer, db.ForeignKey('learning_modules.id'), nullable=False)
    submodule_id = db.Column(db.Integer, db.ForeignKey('learning_submodules.id'), nullable=True)  # NULL for module-level progress
    progress_type = db.Column(db.Enum('module', 'submodule', 'content', 'summary', 'shorts', name='progress_type'), nullable=False)
    status = db.Column(db.Enum('not_started', 'in_progress', 'completed', 'skipped', name='progress_status'), default='not_started')
    completion_percentage = db.Column(db.Float, default=0.0)  # 0.0 to 1.0
    time_spent_minutes = db.Column(db.Integer, default=0)  # Total time spent
    content_viewed = db.Column(db.Boolean, default=False)  # Has viewed long-form content
    summary_viewed = db.Column(db.Boolean, default=False)  # Has viewed summary
    shorts_watched = db.Column(db.Integer, default=0)  # Number of shorts completed
    quiz_attempts = db.Column(db.Integer, default=0)  # Number of quiz attempts
    quiz_best_score = db.Column(db.Float, default=0.0)  # Best quiz score percentage
    last_accessed = db.Column(db.DateTime)  # Last interaction
    started_at = db.Column(db.DateTime)  # When first accessed
    completed_at = db.Column(db.DateTime)  # When completed (NULL if incomplete)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    user = db.relationship('User', backref='learning_progress')
    
    def __repr__(self):
        return f'<UserLearningProgress User:{self.user_id} Module:{self.module_id} Type:{self.progress_type}>'
    
    def mark_complete(self):
        """Mark this progress as completed"""
        self.status = 'completed'
        self.completion_percentage = 1.0
        self.completed_at = datetime.utcnow()
        self.last_accessed = datetime.utcnow()
    
    def update_time_spent(self, additional_minutes):
        """Add time spent to total"""
        self.time_spent_minutes += additional_minutes
        self.last_accessed = datetime.utcnow()


class UserShortsProgress(db.Model):
    """Track user progress through individual short videos"""
    __tablename__ = 'user_shorts_progress'
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    shorts_id = db.Column(db.Integer, db.ForeignKey('video_shorts.id'), nullable=False)
    watch_status = db.Column(db.Enum('not_watched', 'started', 'completed', 'skipped', name='watch_status'), default='not_watched')
    watch_percentage = db.Column(db.Float, default=0.0)  # How much was watched (0.0-1.0)
    watch_time_seconds = db.Column(db.Float, default=0.0)  # Total seconds watched
    replay_count = db.Column(db.Integer, default=0)  # Number of times replayed
    liked = db.Column(db.Boolean, default=False)  # User liked the video
    swipe_direction = db.Column(db.Enum('up', 'down', 'left', 'right', name='swipe_direction'))  # Last swipe
    interaction_quality = db.Column(db.Float, default=0.0)  # Engagement quality score
    first_watched_at = db.Column(db.DateTime)  # First view timestamp
    last_watched_at = db.Column(db.DateTime)  # Most recent view
    completed_at = db.Column(db.DateTime)  # When fully watched (NULL if incomplete)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    user = db.relationship('User', backref='shorts_progress')
    
    # Unique constraint - one progress record per user per video
    __table_args__ = (db.UniqueConstraint('user_id', 'shorts_id', name='_user_shorts_uc'),)
    
    def __repr__(self):
        return f'<UserShortsProgress User:{self.user_id} Short:{self.shorts_id} Status:{self.watch_status}>'
    
    def mark_watched(self, watch_percentage=1.0, watch_time=None):
        """Mark video as watched"""
        self.watch_percentage = watch_percentage
        self.last_watched_at = datetime.utcnow()
        
        if not self.first_watched_at:
            self.first_watched_at = datetime.utcnow()
        
        if watch_time:
            self.watch_time_seconds = max(self.watch_time_seconds, watch_time)
        
        if watch_percentage >= 0.9:  # 90% or more considered completed
            self.watch_status = 'completed'
            self.completed_at = datetime.utcnow()
        elif watch_percentage > 0:
            self.watch_status = 'started'
    
    def toggle_like(self):
        """Toggle like status"""
        self.liked = not self.liked
        return self.liked


class ContentAnalytics(db.Model):
    """Analytics for content performance and user engagement"""
    __tablename__ = 'content_analytics'
    
    id = db.Column(db.Integer, primary_key=True)
    content_type = db.Column(db.Enum('module', 'submodule', 'content', 'summary', 'shorts', name='content_type'), nullable=False)
    content_id = db.Column(db.Integer, nullable=False)  # ID of the content (polymorphic)
    metric_type = db.Column(db.Enum('view', 'completion', 'engagement', 'time_spent', name='metric_type'), nullable=False)
    metric_value = db.Column(db.Float, nullable=False)  # Metric value
    user_count = db.Column(db.Integer, default=1)  # Number of users for this metric
    date = db.Column(db.Date, nullable=False)  # Analytics date
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    def __repr__(self):
        return f'<ContentAnalytics {self.content_type}:{self.content_id} {self.metric_type}:{self.metric_value}>'
